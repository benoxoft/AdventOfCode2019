use std::collections::HashMap;
use crate::intcode::{run_intcode, InputGenerator, OutputHandler};
use std::sync::Mutex;
use std::{thread, time};

#[aoc_generator(day17)]
fn parse_input(input: &str) -> Vec<i64> {    
    let ret = input.split(",").map(|token| token.parse::<i64>().unwrap()).collect();
    ret
}

#[aoc(day17, part1)]
fn find_solution1(input: &Vec<i64>) -> usize {
    let view_str = "..........#####..............................
..........#..................................
..........#..................................
..........#..................................
..........#######............................
................#............................
................#.......#############........
................#.......#...........#........
#######.........#.......#...........#........
#.....#.........#.......#...........#........
#.....#.........#.#####.#.....######O##......
#.....#.........#.#...#.#.....#.....#.#......
#.....#.......##O#O###O##.####O######.#......
#.....#.......#.#.#...#...#...#.......#......
#.....#.......#.##O####...#...#.......#......
#.....#.......#...#.......#...#.......#......
#.....#.######O####.######O####.......#......
#.....#.#.....#.....#.....#...........#......
#.....##O######.....#.....#...........#......
#.......#...........#.....#...........#......
#######.#...........#.....#######.....#######
......#.#...........#...........#...........#
......#.#############...........#...........#
......#.........................#...........#
......#.........................#...........#
......#.........................#...........#
......#.........................#...........#
......#.........................#...........#
......#.........................#.###########
......#.........................#.#..........
......#######...................##O####......
..................................#...#......
..................................#...#......
..................................#...#......
..................................#####......";

    let lines: Vec<&str> = view_str.lines().collect();
    let mut count = 0;

    for i in 0..lines.len() {
        let line = lines[i];
        for j in 0..line.len() {
            let c = line.chars().nth(j).unwrap();
            if c == 'O' {
                count += i * j;
            }
        }
    }
    count
}

#[aoc(day17, part2)]
fn find_solution2(input: &Vec<i64>) -> i64 {
    // L4,L4,L6,R10,L6,L4,L4,L6,R10,L6,L12,L6,R10,L6,R8,R10,L6,R8,R10,L6,L4,L4,L6,R10,L6,R8,R10,L6,L12,L6,R10,L6,R8,R10,L6,L12,L6,R10,L6

    static main_func: &str = "A,A,B,C,C,A,C,B,C,B\nL,4,L,4,L,6,R,10,L,6\nL,12,L,6,R,10,L,6\nR,8,R,10,L,6\nn\n";
    static mut input_pos: usize = 0;

    lazy_static! { 

    }

    let mut program = input.clone();
    program[0] = 2;

    unsafe {
        let ig = || -> InputGenerator {
            Box::new(|| {
                let next_char = main_func.chars().nth(input_pos).unwrap() as u8;
                input_pos += 1;
                next_char as i64
            })
        };
        
        let oh = || -> OutputHandler {
            Box::new(|o: i64| {
                println!("OUTPUT {}", o);
            })
        };
        run_intcode(&mut program.clone(), &ig(), &oh());   
    }    0
}

fn run_intcode_program(input: &Vec<i64>) {
    lazy_static! { 

    }

    let mut program = input.clone();

    unsafe {
        let ig = || -> InputGenerator {
            Box::new(|| {
                0
            })
        };
        
        let oh = || -> OutputHandler {
            Box::new(|o: i64| {
                print!("{}", o as u8 as char);
            })
        };
        run_intcode(&mut program.clone(), &ig(), &oh());   
    }
}